"""Simple Calculator (Portuguese)nnPermite avaliar expressões matemáticas com segurança usando AST, nsuportando: +, -, *, /, //, %, ** e parênteses. nnUso:n  - Modo argumento: python3 simple_calculator.py "2 + 3 * (4 - 1)"n  - Modo interativo: python3 simple_calculator.pyn    - Digite expressões e pressione Entern    - Comandos para sair: sair | quit | exit | qn"""nnfrom __future__ import annotationsnnimport astnimport operatornimport sysnfrom typing import Any, Callable, Mapping, Optional, Unionnnnclass SafeEvaluator(ast.NodeVisitor):n    """Avalia uma expressão matemática simples de forma segura.nn    Permite apenas números, operações binárias (+, -, *, /, //, %, **),n    operações unárias (+, -) e parênteses. Qualquer outro elemento (nomes,n    chamadas de função, atribuições etc.) é bloqueado.n    """nn    Number = Union[int, float]nn    _binary_operators: Mapping[type[ast.AST], Callable[[Number, Number], Number]] = {n        ast.Add: operator.add,n        ast.Sub: operator.sub,n        ast.Mult: operator.mul,n        ast.Div: operator.truediv,n        ast.FloorDiv: operator.floordiv,n        ast.Mod: operator.mod,n        ast.Pow: operator.pow,n    }nn    _unary_operators: Mapping[type[ast.AST], Callable[[Number], Number]] = {n        ast.UAdd: operator.pos,n        ast.USub: operator.neg,n    }nn    def visit_Expression(self, node: ast.Expression) -> Any:  # type: ignore[override]n        return self.visit(node.body)nn    def visit_BinOp(self, node: ast.BinOp) -> Any:  # type: ignore[override]n        left = self.visit(node.left)n        right = self.visit(node.right)n        op_type = type(node.op)nn        if op_type not in self._binary_operators:n            raise ValueError("Operador binário não suportado")nn        func = self._binary_operators[op_type]n        return func(left, right)nn    def visit_UnaryOp(self, node: ast.UnaryOp) -> Any:  # type: ignore[override]n        operand = self.visit(node.operand)n        op_type = type(node.op)nn        if op_type not in self._unary_operators:n            raise ValueError("Operador unário não suportado")nn        func = self._unary_operators[op_type]n        return func(operand)nn    def visit_Constant(self, node: ast.Constant) -> Any:  # type: ignore[override]n        value = node.valuen        if isinstance(value, bool):n            # Evita True/False (subclasses de int)n            raise ValueError("Valores booleanos não são permitidos")n        if not isinstance(value, (int, float)):n            raise ValueError("Apenas números são permitidos")n        return valuenn    # Compatibilidade com versões antigas do Pythonn    def visit_Num(self, node: ast.Num) -> Any:  # type: ignore[override]n        return self.visit_Constant(ast.Constant(node.n))nn    def generic_visit(self, node: ast.AST) -> Any:  # type: ignore[override]n        raise ValueError(n            f"Expressão contém elemento não permitido: {node.__class__.__name__}"n        )nnndef evaluate_expression(expression: str) -> float:n    """Avalia a expressão matemática e retorna o resultado como float/int."""n    try:n        parsed = ast.parse(expression, mode="eval")n    except SyntaxError as exc:n        raise ValueError("Expressão inválida") from excnn    evaluator = SafeEvaluator()n    result = evaluator.visit(parsed)n    return resultnnndef _print_header() -> None:n    print("Calculadora Simples (segura)")n    print("Suporta: +, -, *, /, //, %, ** e parênteses")n    print("Comandos: 'menu' volta ao menu, 'sair'|'quit'|'exit'|'q' encerra")nnnEXIT_COMMANDS = {"sair", "quit", "exit", "q"}nMENU_COMMANDS = {"menu", "m"}nn# Mapeamento direto símbolo -> funçãonOP_SYMBOL_TO_FUNC: Mapping[str, Callable[[SafeEvaluator.Number, SafeEvaluator.Number], SafeEvaluator.Number]] = {n    "+": operator.add,n    "-": operator.sub,n    "*": operator.mul,n    "/": operator.truediv,n    "//": operator.floordiv,n    "%": operator.mod,n    "**": operator.pow,n}nnndef _is_exit(cmd: str) -> bool:n    return cmd.lower() in EXIT_COMMANDSnnndef _is_menu(cmd: str) -> bool:n    return cmd.lower() in MENU_COMMANDSnnndef _parse_number_input(prompt: str) -> Optional[SafeEvaluator.Number]:n    """Lê um número do usuário.nn    Retorna None quando o usuário pede 'menu'.n    Lança SystemExit quando o usuário pede sair.n    """n    while True:n        s = input(prompt).strip()n        if _is_exit(s):n            raise SystemExit(0)n        if _is_menu(s):n            return Nonen        try:n            # Aceita int ou floatn            value = float(s)n            if value.is_integer():n                return int(value)n            return valuen        except ValueError:n            print("Entrada inválida. Digite um número, 'menu' ou 'sair'.")nnndef _choose_operation() -> Optional[str]:n    """Pergunta ao usuário qual operação deseja.nn    Retorna o símbolo da operação (ex: '+').n    Retorna None quando o usuário pede 'menu'.n    Lança SystemExit quando o usuário pede sair.n    """n    ops = " ".join(OP_SYMBOL_TO_FUNC.keys())n    while True:n        s = input(f"Operação ({ops}): ").strip()n        if _is_exit(s):n            raise SystemExit(0)n        if _is_menu(s):n            return Nonen        if s in OP_SYMBOL_TO_FUNC:n            return sn        print("Operação inválida. Use um dos símbolos listados, 'menu' ou 'sair'.")nnndef _guided_loop() -> None:n    print("Modo guiado: informe números e operação. ('menu' volta, 'sair' encerra)")n    while True:n        first = _parse_number_input("Primeiro número: ")n        if first is None:n            return  # menun        op = _choose_operation()n        if op is None:n            return  # menun        second = _parse_number_input("Segundo número: ")n        if second is None:n            return  # menun        try:n            func = OP_SYMBOL_TO_FUNC[op]n            result = func(first, second)n            print(f"Resultado: {result}")n        except ZeroDivisionError:n            print("Erro: divisão por zero não é permitida.")nnndef _expression_loop() -> None:n    print("Modo expressão: digite expressões. ('menu' volta, 'sair' encerra)")n    while True:n        expr = input(">>> ").strip()n        if _is_exit(expr):n            raise SystemExit(0)n        if _is_menu(expr):n            returnn        if not expr:n            continuen        try:n            result = evaluate_expression(expr)n        except Exception as exc:  # noqa: BLE001 - CLI amigáveln            print(f"Erro: {exc}")n            continuen        print(result)nnndef main(argv: list[str]) -> int:n    if argv:n        expr = " ".join(argv)n        try:n            result = evaluate_expression(expr)n        except Exception as exc:  # noqa: BLE001 - CLI amigáveln            print(f"Erro: {exc}", file=sys.stderr)n            return 1n        else:n            print(result)n            return 0nn    _print_header()n    while True:n        try:n            choice = input("Escolha o modo: [1] Guiado | [2] Expressão > ").strip()n        except (EOFError, KeyboardInterrupt):n            print()n            breaknn        if _is_exit(choice):n            breakn        if choice in {"1", "g", "G"}:n            try:n                _guided_loop()n            except SystemExit:n                return 0n        elif choice in {"2", "e", "E"}:n            try:n                _expression_loop()n            except SystemExit:n                return 0n        else:n            print("Opção inválida. Digite 1 (Guiado), 2 (Expressão) ou 'sair'.")nn    return 0nnnif __name__ == "__main__":n    raise SystemExit(main(sys.argv[1:]))